<?php

/**
 * Realizes a login for Google accounts via OpenID 2.0.
 * Uses the user session to store data. Session has to be startet before use.
 *
 * @author Sebastian Herbermann <sebastian.herbermann@googlemail.com>
 * @copyright Sebastian Herbermann, 2009
 * @license http://creativecommons.org/licenses/by-sa/3.0/de/
 *
 */
abstract class OpenID
{
    // Config
    /**
     * Enable or disable debug output.
     *
     * @var boolean
     */
    protected $debug = false;

    /**
     * variable $provider
     * @access protected
     * @var string
     */
     protected $provider;

    // Private values
    /**
     * Given realm.
     *
     * @var String
     */
    protected $realm;
    /**
     * User information.
     *
     * @var String
     */
    protected $user, $email, $lastname, $firstname;

    /**
     * Defaults openid params
     *
     * @var array
     **/
    protected $default_params = array(
      // Login
      'openid.ns' => 'http://specs.openid.net/auth/2.0',
      'openid.mode' => 'checkid_setup',
      'openid.claimed_id' => 'http://specs.openid.net/auth/2.0/identifier_select',
      'openid.identity' => 'http://specs.openid.net/auth/2.0/identifier_select',
      'openid.ns.ext1' => 'http://openid.net/srv/ax/1.0',
      'openid.ext1.mode' => 'fetch_request',
      'openid.ext1.type.email' => 'http://axschema.org/contact/email',
      'openid.ns.ax' => 'http://openid.net/srv/ax/1.0',
      'openid.ax.mode' => 'fetch_request',
      'openid.ax.type.email' => 'http://axschema.org/contact/email',
    );


    /**
     * Constructs the OpenID Object and checks the association handle.
     * Requests a new handle if not valid.
     *
     * @param String $realm Realm for the OpenID login.
     * @param String $provider Name of the provider to use. Available : google
     */
    public function __construct($realm)
    {
        $this->realm = $realm;
#        echo "<pre><br><br> CHECK HANDLE : <br>" . $this->checkHandle();
        $this->checkHandle();
    }

    /**
     * Returns the account identifier (username, mail or sth like that
     * depending on the provider)
     *
     * @return string The identifier.
     * @author Kevin Gomez <contact@kevingomez.fr>
     **/
    public function getAccountIdentifier()
    {
      return $this->getEmail();
    }

    /**
     * Returns the user identifier after a successful login sequence.
     *
     * @return String The user identifier, null if none present.
     */
    public function getUser()
    {
        return $this->user;
    }

    /**
     * Returns the user email after a successful login sequence.
     *
     * @return String The user email, null if none present.
     */
    public function getEmail()
    {
        return $this->email;
    }

    /**
     * Returns the user firstname after a successful login sequence
     *
     * @return String The user firstname, null if none present.
     * @author Camille NERON <camille_neron@carpe-hora.com>
     **/
    public function getFirstname()
    {
        return $this->firstname;
    }

    /**
     * Returns the user lastname after a successful login sequence
     *
     * @return String The user lastname, null if none present.
     * @author Camille NERON <camille_neron@carpe-hora.com>
     **/
    public function getLastname()
    {
        return $this->lastname;
    }

    /**
     * Returns the username after a sucessful login sequence
     * and if the username doesn't exist in database
     *
     * @return string : user nickname
     * @author Camille NERON <camille_neron@carpe-hora.com>
     **/
    public function getUsername()
    {
      if (sfGuardUserQuery::create()->findOneByUsername($this->email))
      {
        return null;
      }
      else
      {
        $pattern ="/(^[._-\w\d]+)@([\w\d.-_]+)/";
        $replace ="$1";
        return preg_replace($pattern, $replace,$this->email);
//        return $this->email;
      }
    }

    /**
     * get the provider url
     *
     * @return string
     * @author Camille NERON <camille_neron@carpe-hora.com>
     **/
    protected function getEndPoint()
    {
      return $this->provider;
    }

    /**
     * Will be called when the auth is complete in order to
     * fill the user information.
     *
     * @param array $params Request parameters.
     *
     * @return void
     * @author Kevin Gomez <contact@kevingomez.fr>
     **/
    protected abstract function getUserParams(array $params);

    /**
     * Checks GET and POST data for a valid OpenID response.
     *
     * @return boolean True, if a valid user identifier was found.
     */
    public function verifyLogin()
    {
      // read response
      $params = $this->readLoginResponse();

      // verify assoc_handle
      if (!$this->checkForValidHandle($params))
      {
        if ($this->debug) echo 'openid_assoc_handle did not match<br>';
        return false;
      }

      if ($this->debug) echo 'handle verified<br>';

      // signature check
      if (!$this->checkSignature($params))
      {
        if ($this->debug) echo 'signatures did not match<br>';
        return false;
      }

      if ($this->debug) echo 'mac-key verified<br>';

      // auth OK !
      $this->getUserParams($params);

      return true;
    }

    /**
     * Checks if the association handle present and valid.
     *
     */
    protected function checkHandle()
    {
        if ( false == ($handle = $this->cacheGet('handle')) )
        {
            $this->renewHandle();
        }
        if ( false == ($handleExpires = $this->cacheGet('handle-expires')) )
        {
            $this->renewHandle();
        }
        if ( $handleExpires < time() )
        {
            $this->renewHandle();
        }
    }

    /**
     * Obtains a new association handle and mac-key from the provider.
     *
     */
    protected function renewHandle()
    {
      $params = array(
        'openid.ns' => 'http://specs.openid.net/auth/2.0',
        'openid.mode' => 'associate',
        'openid.assoc_type' => 'HMAC-SHA1',
        'openid.session_type' => 'no-encryption'
      );

      $response = $this->getResponse($params);
      if (!$response)
      {
        if ($this->debug) echo 'no response received';
        return;
      }

      $params = array();
      preg_match_all( '$([a-z0-9\_]+):(.+)$i', $response, $matches, PREG_SET_ORDER);
      foreach ($matches as $match)
        $params[$match[1]] = $match[2];

      $this->cachePut('handle', $params['assoc_handle']);
      $this->cachePut('handle-expires', time() + $params['expires_in']);
      $this->cachePut('mac', base64_decode($params['mac_key']));
    }

    /**
     * Reads the response var in $_REQUEST
     *
     * @return array Params successfully read
     * @author Kevin Gomez <contact@kevingomez.fr>
     **/
    protected function readLoginResponse()
    {
      $params = array();
      foreach ($_REQUEST as $key => $value)
        if (substr($key, 0, 6) == 'openid')
          $params[$key] = $value;

      return $params;
    }

    protected function computeSignature(array $params)
    {
      // compute signed string
      $signed = '';
      foreach (explode(',', $params['openid_signed']) as $field)
      {
        if (!isset($params['openid_'.str_replace('.','_',$field)]))
        {
          continue;
        }

        $signed .= ''. $field .':'. $params['openid_'.str_replace('.','_',$field)] . "\n";
      }

      // calculate signature and verify
      return base64_encode(hash_hmac('sha1', $signed, $this->getMac(), true));
    }

    /**
     * Check the signature we received with the one we expected.
     *
     * @param array Params received.
     *
     * @return bool
     * @author Kevin Gomez <contact@kevingomez.fr>
     **/
    protected function checkSignature(array $params)
    {
      if (!isset($params['openid_sig']) OR !isset($params['openid_signed']))
      {
        return false;
      }

      // calculate signature and verify
      $signature = $this->computeSignature($params);

      return $params['openid_sig'] == $signature;
    }

    /**
     * Check the transaction handle.
     *
     * @param string $received_handle The received handle.
     *
     * @return bool
     * @author Kevin Gomez <contact@kevingomez.fr>
     **/
    protected function checkForValidHandle($params)
    {
      if (!array_key_exists('openid_assoc_handle', $params))
      {
        return false;
      }

      return $params['openid_assoc_handle'] == $this->getHandle();
    }

    /**
     * Returns the association handle
     *
     * @return String Handle
     */
    protected function getHandle()
    {
      return $this->cacheGet('handle');
    }

    /**
     * Returns the mac-key.
     *
     * @return String Mac
     */
    protected function getMac()
    {
      return $this->cacheGet('mac');
    }

    /**
     * Fetchs the response from the server giving through the OpenID endpoint
     * while passing the given parameters.
     *
     * @param array $params Associative array for parameters to pass
     * @return String Response from the OpenID provider
     */
    protected function getResponse(array $params)
    {
      return file_get_contents($this->buildRequestUrl($params));
    }

    /**
     * Build the request arguments for an GET request.
     *
     * @param array $params Associative array for parameters to pass
     * @return String Arguments for an GET request
     */
    protected function buildRequestUrl(array $params)
    {
      $paramsDefault = array(
        'openid.realm' => $this->realm
      );

      $params = array_merge($paramsDefault, $params);

      return $this->getEndpoint().'?'.http_build_query($params);
    }

    protected function getProviderName()
    {
      return 'OpenID';
    }

    /**
     * Returns a value from the cache.
     *
     * @param String $key
     * @return String
     */
    protected function cacheGet($key)
    {
      if (!isset($_SESSION))
      {
        return null;
      }

      $provider_key = sprintf('%s-%s', $this->getProviderName(), $key);
      $value = array_key_exists($provider_key, $_SESSION) ? $_SESSION[$provider_key] : null;

      if ($this->debug)
      {
        echo "cache call: $key => $value<br>";
      }

      return $value;
    }

    /**
     * Stores a value in the cache.
     *
     * @param String $key
     * @param String $value
     */
    protected function cachePut($key, $value)
    {
      if ($this->debug)
      {
        echo "cache write $key => $value<br>";
      }

      $_SESSION[sprintf('%s-%s', $this->getProviderName(), $key)] = $value;
    }

    public function getLoginJs($returnTo)
    {
      $js = <<<SCRIPT
<script type="text/javascript">
<!--
var openidParams = { realm : '$this->realm', returnToUrl : '$returnTo', opEndpoint : '$provider', onCloseHandler : googleOpenIdLogin, shouldEncodeUrls : 'true' };
var googleOpener = popupManager.createPopupOpener(openidParams);
/*googleOpener.popup(500, 500);*/
//-->
</script>
SCRIPT;
      return $js;
    }
}
