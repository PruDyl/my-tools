<?php
/**
 * @package    T-resa-lib
 * @subpackage  default
 * @author     Julien Muetton <julien_muetton@carpe-hora.com>
 * @copyright  (c) Carpe Hora SARL 2011
 */


/**
 * Skeleton subclass for performing query and update operations on the 'tab_company' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.5.1 on:
 *
 * Thu May 27 10:49:57 2010
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    T-resa-lib
 */
class CompanyQuery extends BaseCompanyQuery
{
  /**
   * count companies the guarsUser is valid member of
   *
   * @return Integer
   **/
  public static function countGuardUserIsValidMemberOf(sfGuardUser $guardUser)
  {
  }
  /**
   * finds a company accessible for given user
   *
   * @param Integer $companyId  the company to retrieve
   * @arapm sfUser  $sf_user    the user to filter for
   * @return Company|null
   **/
  public static function findByIdForUser($companyId, $sfUser)
  {
    return CompanyQuery::create()
        ->_if($sfUser->isAuthenticated())
          ->filterByIsPublic()
        ->_else()
          ->filterForUserView($sfUser->getGuardUser())
        ->_endif()
        ->findOneById($companyId);
  }

  /**
   * filter companies accessible for given guard user.
   * TODO check real credentials for given user (have a company entity ?)
   *
   * @param sfGuardUser $sfGuardUser
   * @return CompanyQuery
   */
  public function filterForUserView($sfGuardUser)
  {
    return $this->filterByIsPublic();
  }

  /**
   * filter companies accessible for not authenticated users
   *
   * @return CompanyQuery
   */
  public function filterByIsPublic()
  {
    return $this
              ->leftJoinCompanyPreferences()
              ->useCompanyPreferencesQuery()
                ->filterByIsPublic(true)
              ->endUse()
              ->leftJoinContract()
              ->useContractQuery()
                ->filterByIsPublic(true)
              ->endUse();
  }

  public function joinCategories()
  {
    return $this
              ->joinLinkCompanyCategory()
              ->useLinkCompanyCategoryQuery()
                ->joinCategory()
              ->endUse();
  }

  /**
   * this function return an insteance of Solr
   *
   * @return instance of solr
   * @author Camille NERON <camille_neron@carpe-hora.com>
   **/
  public static function getSolrService()
  {
    return ProjectConfiguration::getSolrService("companies");
  }

  /**
   * retrun a fully configured Solr query object for company index search.
   *
   * @return Apache_Solr_Query
   * @author Julien Muetton <julien_muetton@carpe-hora.com>
   **/
  public static function getSolrQuery()
  {
    // needed to be called first for centralized inclusion
    $service = self::getSolrService();
    return new Apache_Solr_Query($service);
  }

  /**
   * getSearchQuery
   *
   * @return $query
   * @author Camille NERON <camille_neron@carpe-hora.com>
   **/
  public function getSearchQuery($queryString, $geo_url = null, $maxHits = 0)
  {
    // He ! On peut déjà limiter le nombre de résultats retournés. Cool, non ?!
    if ($maxHits == 0)
    $maxHits = sfConfig::get('app_solr_max_hits', 256);

    $offset = 0;
    $solr = self::getSolrService();

    $response = $solr->search($queryString, $offset, $maxHits);

    // Solr nous renvoie directement du php, vous vous rappelez ?
    $response = json_decode($response->getRawResponse());

    // On se retrouve donc avec une liste de résultas sous forme d'un tableau d'ids
    $pks = array();
    foreach ($response->response->docs as $doc)
    {
      $pks[] = $doc->id;
    }

    if (empty($pks))
    {
      $query = null;
    }
    else
    {
      $query = CompanyQuery::create()
              ->orderByName()
              ->findPks($pks);
    }
    return $query;
  }

} // CompanyQuery
