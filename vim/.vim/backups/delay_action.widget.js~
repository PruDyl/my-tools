(function($, undefined) {

  // used to prevent race conditions with ajax calls
  var ajaxRequestIndex = 0;


  /**
   * DelayAction widget.
   *
   * Used to manage delayed action, triggered by a previously listenned event.
   * It's very usefull in the case of an autocomplete for instance.
   *
   *
   * The following options are available:
   *  - delay (integer, default: 300): given in milliseconds, it represents the
   *    time to wait before really launching the action associated to an event.
   *  - event (string, default: 'change keyup'): the event(s) to bind to the
   *    element. Every event string supported by jQuery will work with this
   *    widget.
   *  - condition (function, default: custom): function used to determine if
   *    we can launch the action (by default, it always returns true). It's
   *    usefull with autocompletes, to avoid making the search when the terms
   *    did not change.
   *  - action (object|function, default: {}): can be both a callback function
   *    to launch or parameters to give to the $.ajax method.
   *    In the case of an ajax call, all the parameters supported by $.ajax are
   *    supported by this widget, except that the 'data' parameter accepts
   *    a function (which will be executed when creating the request).
   *    See the _forceTriggerAction method for more details.
   *
   *
   * Dependancies:
   *  - jquery.ui.widget.js
   */
  $.widget('ui.delayAction', {
    options: {
      delay: 300,
      event: 'change keyup',
      condition: function() { return true; },
      action: {} // ajax parameters or a function
    },

    _init: function() {
      this._observe();
    },
    /**
     * Connect the observed element to the events we are interested in.
     */
    _observe: function() {
      $(this.element).bind(
        this.options.event,
        $.proxy(this._onEventTriggered, this)
      );
    },
    /**
     * Verify if we can fire the action by checking the condition given in the
     * options (by default the condition function returns true).
     *
     * @return {boolean} True if the conditions are verified, false otherwise.
     */
    _isEventConditionVerified: function(event) {
      var cond = this.options.condition;

      return cond(event);
    },
    /**
     * Really launches the action, without any delay or check. If the action is
     * a function, we call it. Otherwise we use the 'action' option as an
     * object representing the parameters to pass to the ajax call.
     *
     * In the case of an ajax call, the 'complete', 'error' and 'success'
     * options are overridden so that we can do some checks to avoid condition
     * race issues.
     * The nice thing is that it's still possible for you to define your
     * callbacks as they will be called with the original parameters just after
     * our checks.
     *
     * Note :
     * As the ajax data is given as an option, at the initialization of the
     * widget, we can not use the original data option as we would not be able
     * to define dynamic data. The modified data option is a workaround to this
     * problem: it's now possible to give a function instead of a pure data
     * string. This function will be called at the request creation.
     *
     * The 'delayedActionTriggered' event is fired, juste before the action
     * is started. It holds the original event as unique argument.
     */
    _forceTriggerAction: function(event) {
      if (undefined === this.ajaxRequestIndex) {this.ajaxRequestIndex = 0;}
      var action = this.options.action;

      this._trigger('delayedActionTriggered', event);

      if ($.isFunction(action)) {
        action(event);
        return;
      }

      // kill the previous xhr request
      if (this.xhr) {

        this.xhr.abort();
      }

      var self = this;
      var xhr_parameters = $.extend({}, action, {
        delayedRequestIndex: ++self.ajaxRequestIndex,
        // override the complete callback
        complete: function(jqXHR, textStatus) {
          if (!self._isValidAjaxRequest.call(self, this.delayedRequestIndex)) {
            return;
          }

          if ($.isFunction(self.options.action.complete)) {
            var func = self.options.action.complete;

            func(jqXHR, textStatus);
          }
        },
        // override the error callback
        error: function(jqXHR, textStatus, errorThrown) {
          if (!self._isValidAjaxRequest.call(self, this.delayedRequestIndex)) {
            return;
          }

          // don't signal aborted calls as errors
          if (textStatus === 'abort' || errorThrown === undefined) {
            return;
          }

          if ($.isFunction(self.options.action.error)) {
            var func = self.options.action.error;

            func(jqXHR, textStatus, errorThrown);
          }
        },
        // override the success callback
        success: function(data, textStatus, jqXHR) {
          if (!self._isValidAjaxRequest.call(self, this.delayedRequestIndex)) {
            return;
          }

          if ($.isFunction(self.options.action.success)) {
            var func = self.options.action.success;

            func(data, textStatus, jqXHR);
          }
        }
      });

      if ($.isFunction(action.data)) {
        var data_getter = action.data;
        xhr_parameters.data = data_getter();
      }

      this.xhr = $.ajax(xhr_parameters);
    },
    /**
     * Cancels the action. It just clears the timeout event.
     */
    _cancelAction: function(event) {
      clearTimeout(this.event_timeout);
    },
    /**
     * Defines the timeout event with the given delay and action.
     */
    _startAction: function(event) {
      var self = this;
      this.event_timeout = setTimeout(function() {
        // only search if the value has changed
        if (self._isEventConditionVerified(event)) {
          self._forceTriggerAction(event);
        }
      }, self.options.delay);
    },
    /**
     * Tells if the given request number is the one we expected. It allows the
     * script to return the right ajax request results.
     *
     * @return {boolean} True when the number is correct, false otherwise.
     */
    _isValidAjaxRequest: function(request_no) {
      return request_no === this.ajaxRequestIndex;
    },

    /**
     * Called when the observed event is triggered. It cancels all the
     * previously started actions and re-inits the timeout clock to start a
     * fresh new one.
     */
    _onEventTriggered: function(event) {
      this._cancelAction(event);
      this._startAction(event);
    }
  });
})(jQuery);
