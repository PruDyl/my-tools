<?php
/**
 * @package    T-resa-lib
 * @subpackage  default
 * @author     Julien Muetton <julien_muetton@carpe-hora.com>
 * @copyright  (c) Carpe Hora SARL 2011
 */



/**
 * Skeleton subclass for performing query and update operations on the 'tab_company_entity' table.
 *
 *
 *
 * This class was autogenerated by Propel 1.5.2 on:
 *
 * Thu Jul 29 15:49:59 2010
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    T-resa-lib
 */
class CompanyEntityQuery extends BaseCompanyEntityQuery
{
  protected static $sfUser = null;

  /**
   * set the application user
   **/
  public static function setUser($user)
  {
    self::$sfUser = $user;
  }

  /**
   * return the currently connected user
   *
   * @return sfGuardSecurityUser
   **/
  public function getUser()
  {
    if (!is_null(self::$sfUser))
    {
      return self::$sfUser;
    }
    throw new sfException('please register the current user in CompanyEntityQuery');
  }

  /**
   * filter only ones that are valid and linked to $sfGuardUser
   *
   * @param sfGuardUser $sfGuardUser the gurad user to check for
   * @return CompanyEntityQuery
   **/
  public function filterValidForGuardUser($sfGuardUser)
  {
    return $this
      ->_if($sfGuardUser && $sfGuardUser->getId())
        ->filterByUserId($sfGuardUser->getId())
      ->_else()
        ->where('FALSE');
      ->_endif();
  }

  /**
   * filter for the current context company
   *
   * @return CompanyEntityQuery
   **/
  public function filterForSelectedCompany()
  {
    return $this->filterByCompany($this->getUser()->getSelectedCompany());
  }

  public function filterForQuery($query)
  {
    $queries = preg_split('#[\s-]#', strtoupper(iconv('UTF-8', 'US-ASCII//TRANSLIT', $query)));
    $conditionCounter = 0;
    $conditions = array();

    foreach ($queries as $q)
    {
      $curQuery = sprintf('%%%s%%', $q);

      $conditionCounter = $conditionCounter + 1;
      $condition1 = sprintf('cond%d', $conditionCounter);
      $this->condition($condition1, sprintf('%s.SearchIndex LIKE ?', $this->getModelAliasOrName()), $curQuery);

      $conditions[] = $condition1;
    }

    $this->where($conditions, 'and');

    return $this;
  }

  public function withExtraProperties()
  {
    //TODO check where it is called -> seems it's not.
    $this->leftJoinWithCompanyEntityExtraFormField();
    return $this;

  }

  /**
   * filter for given CompanyEntity company.
   * if $contractor is a number, then a query is used to retrieve related object.
   *
   * @param CompanyEntity|integer   $contractor   the contractor from which to retrieve company id.
   *
   * @return CompanyEntityQuery
   **/
  public function filterForEntityCompany($contractor)
  {
    if (is_numeric($contractor))
    {
      $contractor = CompanyEntityQuery::create()->findPk($contractor);
    }
    return $this
              ->filterByCompanyId($contractor->getCompanyId());
  }

  /**
   * join the assistance relations for given company entity.
   *
   * @param CompanyEntity|Integer $contractor       the company entity to use
   * @param string                $relationAlias    the alias name
   * @param string                $joinType         the join type to use
   *
   * @return CompanyEntityQuery
   */
  public function joinAssistantLinkFor($contractor, $relationAlias = 'AssistantLink', $joinType = 'LEFT JOIN')
  {
    $contractorId = is_numeric($contractor) ? $contractor : $contractor->getId();
    $alias = AssistantLinkPeer::alias($relationAlias, AssistantLinkPeer::ASSISTED_BY_ID);

    $this
      ->leftJoinAssistantLink($relationAlias, $joinType)
    /*
      //using propel <= 1.5
      ->getJoin($relationAlias)
                ->addCondition(AssistantLinkPeer::alias($relationAlias, AssistantLinkPeer::ASSISTED_BY_ID), $contractorId);
    /*/
      // using propel >= 1.6
      ->addJoinCondition($relationAlias, sprintf('%s.AssistedById = ?', $relationAlias), $contractorId);
    //*/

    return $this;
  }

  protected function conditionForAccessFor($accessType, $contractor, $rights, $cond_name)
  {
    $contractorId = is_numeric($contractor) ? $contractor : $contractor->getId();

    return $this
              ->filterForEntityCompany($contractor)
              ->joinAssistantLinkFor($contractorId)
              // is the given contractor
              ->condition('his', sprintf('%s.Id = ?', $this->getModelAliasOrName()), $contractorId)
              // is with assistant link
              ->condition('cond_assistant', 'AssistantLink.Id IS NOT NULL')
              // assistant link has rights to $accessType
              ->condition('cond_assistant_rights', sprintf('CAST(AssistantLink.%s & ? AS BOOLEAN)', $accessType), $rights)
              // has no assistance link
              ->condition('cond_no_assistant', 'AssistantLink.Id IS NULL')
              // default rights for $accessType
              ->condition('cond_no_assistant_rights', sprintf('CAST(%s.%s & ? AS BOOLEAN)', $this->getModelAliasOrName(), $accessType), $rights)
              // has assistance link and has $accessType
              ->combine(array('cond_assistant', 'cond_assistant_rights'), 'and', 'case_assistant')
              // has no assistance link and default rights for $accessType
              ->combine(array('cond_no_assistant', 'cond_no_assistant_rights'), 'and', 'case_no_assistant')
              // in any of the given conditions
              ->combine(array('his', 'case_assistant', 'case_no_assistant'), 'or', $cond_name);
  }

  protected function filterByAccessFor($accessType, $contractor, $rights)
  {
    return $this
      ->conditionForAccessFor($accessType, $contractor, $rights, 'access_for')
      ->where(array('access_for'), 'AND');
  }

  /**
   * filter entities currently connected user can access with $rights
   * @param Company     $company
   * @param sfGuardUser $guardUser
   * @retorn CompanyEntityQuery
   **/
  protected function filterByCalendarPublishedForCurrentFor($company, $guardUser = null)
  {
    return $this
      ->joinLinkCalendarEntity()
      ->useLinkCalendarEntityQuery()
        ->joinCalendar()
        ->useCalendarQuery()
          ->filterForGuardUser($company, $guardUser)
        ->endUse()
      ->endUse();
  }

  /**
   * filters the company entities $contractor can access company calendars
   * with given $rights.
   * rigths is a combination of
   *  * Calendar::RIGHT_VIEW,
   *  * Calendar::RIGHT_UPDATE,
   *  * Calendar::RIGHT_CREATE,
   *  * Calendar::RIGHT_DELETE,
   *  * Calendar::RIGHT_FULL,
   */
  public function filterByCalendarVisibleFor($contractor, $rights)
  {
    return $this->filterByAccessFor('AccessCalendarCompany', $contractor, $rights);
  }

  /**
   * filters the company entities $contractor can access events of
   * with given $rights
   */
  public function filterByProtectedCalendarVisibleFor($contractor, $rights)
  {
    return $this->filterByAccessFor('AccessCalendarProtected', $contractor, $rights);
  }

  /**
   * filter query with condition $contractor can access a calendar of with $right
   *
   * @return CompanyEntityQuery
   **/
  public function filterByAnyCalendarAccessFor($contractor, $rights)
  {
    return $this
      ->conditionForAccessFor('AccessCalendarCompany', $contractor, $rights, 'visible')
      ->conditionForAccessFor('AccessCalendarCompany', $contractor, $rights, 'protected')
      ->where(array('visible', 'protected'), 'OR');
  }

  /**
   * filters the company entities $contractor can access public contacts of
   * with given $rights
   */
  public function filterByPublicContactAccessFor($contractor, $rights)
  {
    return $this->filterByAccessFor('AccessContactCompany', $contractor, $rights);
  }

  public function conditionForPublicContactAccessFor($contractor, $rights, $cond_name)
  {
    return $this->conditionForAccessFor('AccessContactCompany', $contractor, $rights, $cond_name);
  }

  public function conditionForProtectedContactAccessFor($contractor, $rights, $cond_name)
  {
    return $this->conditionForAccessFor('AccessContactProtected', $contractor, $rights, $cond_name);
  }

  /**
   * filters the company entities $contractor can access protected contacts of
   * with given $rights
   */
  public function filterByProtectedContactAccessFor($contractor, $rights)
  {
    return $this->filterByAccessFor('AccessContactProtected', $contractor, $rights);
  }

  /**
   * shortcut to joinCredentialObject
   *
   * @param     string $relationAlias optional alias for the relation
   * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
   *
   * @return    CompanyEntityQuery The current query, for fluid interface
   * @author Julien Muetton <julien_muetton@carpe-hora.com>
   **/
  public function joinCredential($relationAlias = null, $joinType = Criteria::INNER_JOIN)
  {
    return $this->joinCredentialObject($relationAlias, $joinType);
  }

  /**
   * shortcut to filterByCredentialObject
   *
   * @param     CompanyEntityCredential $companyEntityCredential  the related object to use as filter
   * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
   *
   * @return    CompanyEntityQuery The current query, for fluid interface
   * @author Julien Muetton <julien_muetton@carpe-hora.com>
   **/
  public function filterByCredential($companyEntityCredential, $comparison = null)
  {
    return filterByCredentialObject($companyEntityCredential, $comparison);
  }

  public function filterByPublicContactsDirectory(Contractor $contractor)
  {
    return $this
      ->condition('contractor', 'CompanyEntity.Id != ?', $contractor->getId())
      ->condition('company', 'CompanyEntity.CompanyId = ?', $contractor->getCompany()->getId())
      ->conditionForDirectoryVisibility(ContactQuery::COMPANY_VISIBILITY, 'visibilities')

      ->where(array('visibilities', 'contractor', 'company'))
    ;
  }

  public function conditionForDirectoryVisibility($visibility, $cond_name)
  {
    return $this
      ->leftJoin('Company co')
      ->leftJoin('co.CompanyPreferences co_conf')

      ->condition('e_visibility_pub', 'CompanyEntity.ContactsDefaultVisibility = ?', $visibility)

      ->condition('e_visibility_par', 'CompanyEntity.ContactsDefaultVisibility = ?', ContactQuery::PARENT_VISIBILITY)
      ->condition('co_visibility', 'co_conf.ContactsDefaultVisibility = ?', $visibility)


      ->combine(array('e_visibility_par', 'co_visibility'), 'AND', 'visib_parent')

      ->combine(array('visib_parent', 'e_visibility_pub'), 'OR', $cond_name)
    ;
  }

  /**
   * filter for company entities having given user as a contact.
   *
   * @param   Company     $company        The reference company.
   * @param   sfGuarduser $guardUser the user to filter for
   * @return CompanyEntityQuery
   */
  public function filterByContactOfUserInCompany($company, $sfGuardUser, $checked_deleted = true)
  {
    if (!$sfGuardUser)
    {
      throw new LogicException();
    }
    $uid= uniqid();

    return $this
        ->filterByCompany($company)
        ->createConditionUserInEntityDirectory($sfGuardUser, $uid.'entity_dir', $checked_deleted)
        ->createConditionUserInCompanyDirectory($company, $sfGuardUser, $uid.'company_dir', $checked_deleted)
        ->where(array($uid.'entity_dir', $uid.'company_dir'), 'OR');
  }

  /**
   * create a condition for user in company entity directory
   *
   * @return CompanyEntityQuery
   * @author Julien Muetton <julien_muetton@carpe-hora.com>
   **/
  protected function createConditionUserInEntityDirectory($sfGuardUser, $cond_name, $check_deleted = true)
  {
    $uid= uniqid();
    return $this
      ->leftJoinContactEntity('ce_ce')
      ->useQuery('ce_ce')
        ->leftJoinContact('ce_ce_c')
      ->endUse()
      ->condition($uid.'profile_entity_contact', 'ce_ce_c.ProfileId IN ?', $sfGuardUser->getsfGuardProfiles()->toKeyValue('Id', 'Id'))
      ->_if($check_deleted)
        ->condition($uid.'_not_deleted', 'ce_ce.DeletedAt IS NULL')
        ->combine(array($uid.'_not_deleted', $uid.'profile_entity_contact'), 'AND', $cond_name)
      ->_else()
        ->combine(array($uid.'profile_entity_contact'), 'AND', $cond_name)
      ->_endif()
      ;
  }

  /**
   * undocumented function
   *
   * @return void
   * @author Julien Muetton <julien_muetton@carpe-hora.com>
   **/
  protected function createConditionUserInCompanyDirectory(Company $company, $sfGuardUser, $cond_name, $check_deleted = true)
  {
    $uid = uniqid();

    return $this
      ->leftJoinCompany('ce_c')
      ->useQuery('ce_c')
        ->leftJoinContactCompany('ce_c_cc')
        ->useQuery('ce_c_cc')
          ->leftJoinContact('ce_c_cc_c')
        ->endUse()
      ->endUse()
      ->condition($uid.'profile_comp_contact', 'ce_c_cc_c.ProfileId IN ?', $sfGuardUser->getsfGuardProfiles()->toKeyValue('Id', 'Id'))
      ->_if($check_deleted)
        ->condition($uid.'_not_deleted', 'ce_c_cc.DeletedAt IS NULL')
        ->combine(array($uid.'_not_deleted', $uid.'profile_comp_contact'), 'AND', $cond_name)
      ->_else()
        ->combine(array($uid.'profile_comp_contact'), 'AND', $cond_name)
      ->_endif()
      ;
  }

  /**
   * create a query to filter enities having user as contact
   *
   * @param   Company     $company        The reference company.
   * @param   sfGuarduser $guardUser the user to filter for
   * @return CompanyEntityQuery
   */
  public static function createFilterForUserAsContact(Company $company, $sfGuardUser)
  {
    return CompanyEntityQuery::create()
      ->filterByContactOfUserInCompany($company, $sfGuardUser);
  }

  /**
   * create a query to filter
   */
  public static function createFilterInCompany(Company $company)
  {
    return CompanyEntityQuery::create()
      ->filterByCompany($company);
  }

  /**
   * find for API view
   *
   * @return PropelCollection
   **/
  public function findForApi($companyId)
  {
    return $this->filterByCompanyId($companyId)
              ->orderByCompanyName()
              ->find();
  }

  /**
   * find entity ids for which $entity has AccessCalendar $right
   *
   * @param CompanyEntity $entity the company entity to filter for.
   * @param Integer       $rights rights to check against (Calendar rights)
   * @return array()
   **/
  public static function findIdsICanAccessCalendarWithRights(CompanyEntity $entity, $rights)
  {
    return CompanyEntityQuery::create()
      ->select(array('Id'))
      ->filterByCalendarVisibleFor($entity, $rights)
      ->find();
  }

  /**
   * find entity ids for which $entity has AccessProtectedCalendar $right
   *
   * @param CompanyEntity $entity the company entity to filter for.
   * @param Integer       $rights rights to check against (Calendar rights)
   * @return array()
   **/
  public static function findIdsICanAccessProtectedCalendarWithRights(CompanyEntity $entity, $rights)
  {
    return CompanyEntityQuery::create()
      ->select(array('Id'))
      ->filterByProtectedCalendarVisibleFor($entity, $rights)
      ->find();
  }

  /**
   * find every CompanyEntity $contractor can access a calendar with $right
   *
   * @return PropelCollection
   **/
  public static function findWithCalendarEntityCanAccess($entity, $right)
  {
    return CompanyEntityQuery::create()
        ->filterByAnyCalendarAccessFor($entity, $right)
        ->distinct()
        ->find();
  }

  /**
   * find every company entity from $company $sf_user can access a clendar of
   *
   * @return PropelCollection
   **/
  public static function findWithCalendarInCompanyUserCanAccess($company, $right)
  {
    $sf_user = self::$sfUser;
    $guardUser = $sf_user->isAuthenticated() ? $sf_user->getGuardUser() : null;
    return CompanyEntityQuery::create()
        ->filterByCalendarPublishedForCurrentFor($company, $guardUser)
        ->distinct()
        ->find();
  }
} // CompanyEntityQuery
